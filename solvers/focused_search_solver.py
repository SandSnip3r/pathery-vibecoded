
from typing import Tuple, List, Optional, Any
from pathery_env_adapter import PatheryEnvAdapter as PatheryEmulator
from solvers.base_solver import BaseSolver
import random
import heapq

class FocusedSearchSolver(BaseSolver):
    """
    A solver that uses a focused beam search algorithm.
    """

    def __init__(self, emulator: PatheryEmulator, beam_width: int = 10, search_depth: int = 5, best_known_solution: int = 0, **kwargs: Any) -> None:
        """
        Initializes the FocusedSearchSolver.

        Args:
            emulator (PatheryEmulator): An instance of the PatheryEmulator.
            beam_width (int): The number of candidates to keep in the beam.
            search_depth (int): The depth of the search.
            best_known_solution (int): The best known solution length.
        """
        super().__init__(emulator, best_known_solution)
        self.beam_width = beam_width
        self.search_depth = search_depth

    def solve(self) -> Tuple[Optional[List[Tuple[int, int]]], int]:
        """
        Attempts to find the longest path using a focused beam search.

        Returns:
            tuple: A tuple containing the best path found and its length.
        """
        self._clear_walls()
        self._randomly_place_walls(self.emulator.num_walls)
        
        initial_walls = self.emulator.get_wall_locations()
        initial_path, initial_length = self.emulator.find_path()

        if not initial_path:
            return None, 0

        beam = [(initial_length, initial_walls)]
        best_length = initial_length
        best_walls = initial_walls

        for _ in range(self.search_depth):
            candidates = []
            for length, walls in beam:
                for new_walls in self._get_neighbors(walls):
                    self.emulator.set_walls(new_walls)
                    path, path_length = self.emulator.find_path()
                    if path:
                        heapq.heappush(candidates, (-path_length, new_walls))

            beam = []
            seen_walls = set()
            while candidates and len(beam) < self.beam_width:
                length, walls = heapq.heappop(candidates)
                walls_tuple = tuple(sorted(walls))
                if walls_tuple not in seen_walls:
                    beam.append((-length, walls))
                    seen_walls.add(walls_tuple)

            if not beam:
                break

            current_best_length, current_best_walls = beam[0]

            if current_best_length > best_length:
                best_length = current_best_length
                best_walls = current_best_walls

        self.emulator.set_walls(best_walls)
        best_path, _ = self.emulator.find_path()

        return best_path, best_length

    def _get_neighbors(self, walls: List[Tuple[int, int]]) -> List[List[Tuple[int, int]]]:
        """
        Generates neighbors of a given wall configuration.
        A neighbor is generated by moving a single wall to a new empty location.
        """
        neighbors = []
        empty_cells = self.emulator.get_empty_cells()
        
        for i, wall_to_move in enumerate(walls):
            for empty_cell in random.sample(empty_cells, min(len(empty_cells), 10)):
                new_walls = walls[:i] + walls[i+1:]
                new_walls.append(empty_cell)
                neighbors.append(new_walls)
        
        return neighbors
