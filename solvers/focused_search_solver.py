
import time
from typing import Tuple, List, Optional, Any
from pathery_env.envs.pathery import PatheryEnv, CellType
from solvers.base_solver import BaseSolver
import random
import heapq
import numpy as np

class FocusedSearchSolver(BaseSolver):
    """
    A solver that uses a focused beam search algorithm.
    """

    def __init__(self, env: PatheryEnv, beam_width: int = 10, search_depth: int = 5, best_known_solution: int = 0, time_limit: Optional[int] = None, **kwargs: Any) -> None:
        """
        Initializes the FocusedSearchSolver.

        Args:
            env (PatheryEnv): An instance of the PatheryEnv.
            beam_width (int): The number of candidates to keep in the beam.
            search_depth (int): The depth of the search.
            best_known_solution (int): The best known solution length.
            time_limit (Optional[int]): The time limit in seconds for the solver.
        """
        super().__init__(env, best_known_solution, time_limit)
        self.beam_width = beam_width
        self.search_depth = search_depth

    def solve(self) -> Tuple[Optional[List[Tuple[int, int]]], int]:
        """
        Attempts to find the longest path using a focused beam search.

        Returns:
            tuple: A tuple containing the best path found and its length.
        """
        self.start_time = time.time()
        self._clear_walls()
        self._randomly_place_walls(self.env.wallsToPlace)

        initial_walls = np.where(self.env.grid == CellType.WALL.value)
        initial_walls = list(zip(initial_walls[1], initial_walls[0]))
        initial_path = self.env._calculateShortestPath()
        initial_length = len(initial_path)

        if not initial_path.any():
            return None, 0

        beam = [(initial_length, initial_walls)]
        best_length = initial_length
        best_walls = initial_walls

        for i in range(self.search_depth):
            if self.time_limit and (time.time() - self.start_time) > self.time_limit:
                print(f"Time limit reached. Exiting after {i} iterations.")
                break
            candidates = []
            for length, walls in beam:
                for new_walls in self._get_neighbors(walls):
                    self._clear_walls()
                    for x, y in new_walls:
                        self.env.step((y, x))
                    path = self.env._calculateShortestPath()
                    if path.any():
                        heapq.heappush(candidates, (-len(path), new_walls))

            beam = []
            seen_walls = set()
            while candidates and len(beam) < self.beam_width:
                length, walls = heapq.heappop(candidates)
                walls_tuple = tuple(sorted(walls))
                if walls_tuple not in seen_walls:
                    beam.append((-length, walls))
                    seen_walls.add(walls_tuple)

            if not beam:
                break

            current_best_length, current_best_walls = beam[0]

            if current_best_length > best_length:
                best_length = current_best_length
                best_walls = current_best_walls

        self._clear_walls()
        for x, y in best_walls:
            self.env.step((y, x))
        best_path = self.env._calculateShortestPath()

        return best_path, best_length

    def _get_neighbors(self, walls: List[Tuple[int, int]]) -> List[List[Tuple[int, int]]]:
        """
        Generates neighbors of a given wall configuration.
        A neighbor is generated by moving a single wall to a new empty location.
        """
        neighbors = []
        empty_cells = np.where(self.env.grid == CellType.OPEN.value)
        empty_cells = list(zip(empty_cells[1], empty_cells[0]))

        for i, wall_to_move in enumerate(walls):
            for empty_cell in random.sample(empty_cells, min(len(empty_cells), 10)):
                new_walls = walls[:i] + walls[i+1:]
                new_walls.append(empty_cell)
                neighbors.append(new_walls)

        return neighbors
